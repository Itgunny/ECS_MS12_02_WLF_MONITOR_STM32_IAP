###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.1.4415/W32 for ARM      23/Jan/2017  15:40:55 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_IAP\Pla #
#                    tform\SRC\System_Init.c                                  #
#    Command line =  D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_IAP\Pla #
#                    tform\SRC\System_Init.c -D USE_STDPERIPH_DRIVER -D       #
#                    STM32F4XX -D USE_STM324xG_EVAL -D USE_FULL_ASSERT -lcN   #
#                    D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_IAP\Pro #
#                    ject\Debug\List\ -o D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_M #
#                    ONITOR_STM32_IAP\Project\Debug\Obj\ --debug              #
#                    --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp        #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32 #
#                    _IAP\Project\..\Platform\INC\ -I                         #
#                    D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_IAP\Pro #
#                    ject\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include\ -I  #
#                    D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_IAP\Pro #
#                    ject\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\ -I     #
#                    D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_IAP\Pro #
#                    ject\..\Utilities\STM32_EVAL\Common\ -I                  #
#                    D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_IAP\Pro #
#                    ject\..\Utilities\STM32_EVAL\STM3240_41_G_EVAL\ -Oh      #
#                    --use_c++_inline -I "C:\Program Files (x86)\IAR          #
#                    Systems\Embedded Workbench 6.5\arm\CMSIS\Include\"       #
#    List file    =  D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_IAP\Pro #
#                    ject\Debug\List\System_Init.lst                          #
#    Object file  =  D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_IAP\Pro #
#                    ject\Debug\Obj\System_Init.o                             #
#                                                                             #
#                                                                             #
###############################################################################

D:\GIT\WLF_MONITOR\ECS_MS12_02_WLF_MONITOR_STM32_IAP\Platform\SRC\System_Init.c
      1          /**
      2            ******************************************************************************
      3            * @file    System_Init.c 
      4            * @author  kutelf (kutelf@taeha.co.kr)
      5            * @version V1.0.0
      6            * @date    02/22/2013
      7            * @brief   System_Init.c module
      8            *
      9            * Project Name       : WL9F Display IAP
     10            * Project Enviroment : IAREmbedded Workbench for ARM 6.5x 
     11            *                      STM32F407ZGT6 Firmware Library
     12            * Project Workspace  : WL9F_Display_IAP
     13            * MCU Type           : STM32F407ZGT6
     14            *
     15            * TAEHA MECHATRONICS Co., Ltd (http://www.taeha.co.kr)				
     16            * ECS Division R&D Center. / Author by Young-Min Han (kutelf@taeha.co.kr)
     17            * 
     18            ******************************************************************************
     19            */ 
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "WL9F_Display_IAP.h"	
     23          
     24          #include "WL9F_Monitor_IAP.h"
     25          
     26          
     27          /* Private typedef -----------------------------------------------------------*/
     28          /* Private define ------------------------------------------------------------*/
     29          /* Private macro -------------------------------------------------------------*/
     30          /* Private variables ---------------------------------------------------------*/
     31          // EEPROM Clear Variables
     32          WL9FM_SaveE2PROM1		*SaveE2PROM1;
     33          WL9FM_SaveE2PROM2		*SaveE2PROM2;
     34          WL9FM_SaveE2PROM3		*SaveE2PROM3;
     35          
     36          WL9FM_SaveE2PROMoniInfo	*SaveE2PROMoniInfo;
     37          
     38          WL9F_DATA_RTC   	    WL9FM_RTC;
     39          
     40          /* Private function prototypes -----------------------------------------------*/
     41          /* Private functions ---------------------------------------------------------*/
     42          
     43          void Init_RTC(void)
     44          {
     45              WL9FM_RTC.Year   = 0;
     46          	WL9FM_RTC.Month  = 1;
     47          	WL9FM_RTC.Date   = 1;
     48          	WL9FM_RTC.Day    = 1;
     49          	WL9FM_RTC.Hour   = 12;
     50          	WL9FM_RTC.Minute = 0;
     51          	WL9FM_RTC.Second = 0;
     52          
     53          	WRITE_RTC(WL9FM_RTC);
     54          }
     55          
     56          void InitE2PROM(void)
     57          {
     58          	u8 i;
     59          	u8 tmpBuf1[8];
     60          	u8 tmpBuf2[8];
     61          	u8 tmpBuf3[8];
     62          	u8 tmpBuf4[21];
     63          	
     64          	SaveE2PROM1 = (WL9FM_SaveE2PROM1*)&tmpBuf1[0];
     65          	SaveE2PROM2 = (WL9FM_SaveE2PROM2*)&tmpBuf2[0];
     66          	SaveE2PROM3 = (WL9FM_SaveE2PROM3*)&tmpBuf3[0];
     67          	SaveE2PROMoniInfo = (WL9FM_SaveE2PROMoniInfo*)&tmpBuf4[0];
     68          
     69          	SaveE2PROM1->WorkLoad 				= 0;
     70          	SaveE2PROM1->testWorkLoad 			= 0;
     71          	SaveE2PROM1->Unit 					= 3;	//	섭씨 ( C ) , km/h
     72          	SaveE2PROM1->DispType	 			= 0;
     73          	SaveE2PROM1->InfoViewPriority 		= 0;
     74          	SaveE2PROM1->UnitPressure 			= 0;
     75          	SaveE2PROM1->Reserved0 				= 0;
     76          	SaveE2PROM1->Lang 					= 0;
     77          	SaveE2PROM1->ManualBackLight 		= 7;
     78          	SaveE2PROM1->AutoBackLight 			= 0;
     79          	SaveE2PROM1->TopInfoView 			= 1;	// 	Hyd Temp
     80          	SaveE2PROM1->BottomInfoView 		= 3;	// 	Cool Temp
     81          	SaveE2PROM1->InfoViewCnt 			= 2;
     82          	SaveE2PROM1->HR_Start 				= 0;
     83          	SaveE2PROM1->RearCamReverseMode 	= 0;	// 	Off
     84          	SaveE2PROM1->ActiveCamNum 			= 1;
     85          	SaveE2PROM1->FirstCam 				= 0;
     86          	SaveE2PROM1->SecondCam 				= 1;
     87          	SaveE2PROM1->ThirdCam 				= 2;
     88          	SaveE2PROM1->Reserved1 				= 0;
     89          
     90          	SaveE2PROM2->LightMode 				= 0;
     91          	SaveE2PROM2->JobTimeView 			= 0;
     92          	SaveE2PROM2->OdoMeterView 			= 0;
     93          	SaveE2PROM2->JobOdoSelect 			= 0;
     94          	SaveE2PROM2->LightLowTime 			= 8;
     95          	SaveE2PROM2->LightUpperTime 		= 16;
     96          	SaveE2PROM2->AutoLightDay 			= 0;
     97          	SaveE2PROM2->AutoLightNight 		= 0;
     98          	SaveE2PROM2->Reserved1 				= 0;
     99          
    100          	SaveE2PROM3->Phone_1  				= 0;
    101          	SaveE2PROM3->Phone_2  				= 8;
    102          	SaveE2PROM3->Phone_3  				= 0;
    103          	SaveE2PROM3->Phone_4  				= 5;
    104          	SaveE2PROM3->Phone_5  				= 5;
    105          	SaveE2PROM3->Phone_6  				= 5;
    106          	SaveE2PROM3->Phone_7  				= 8;
    107          	SaveE2PROM3->Phone_8  				= 2;
    108          	SaveE2PROM3->Phone_9  				= 7;
    109          	SaveE2PROM3->Phone_10 				= 2;
    110          	SaveE2PROM3->Phone_11 				= 0xf;
    111          	SaveE2PROM3->Phone_12 				= 0xf;
    112          
    113          #if 1	// Monitor Change History - temp
    114          	SaveE2PROMoniInfo->ManufactureYear  = 0;
    115          	SaveE2PROMoniInfo->ManufactureMonth = 0;
    116          	SaveE2PROMoniInfo->ManufactureDay   = 0;
    117          	SaveE2PROMoniInfo->MoniPorgramVer   = 0;
    118          	SaveE2PROMoniInfo->MoniSerialNo[0]  = 0;	// 0
    119          	SaveE2PROMoniInfo->MoniSerialNo[1]  = 0;	// 9
    120          	SaveE2PROMoniInfo->MoniSerialNo[2]  = 0;	// 0
    121          	SaveE2PROMoniInfo->MoniSerialNo[3]  = 0;	// 8
    122          	SaveE2PROMoniInfo->MoniSerialNo[4]  = 0;	// M
    123          	SaveE2PROMoniInfo->MoniSerialNo[5]  = 0;	// 0
    124          	SaveE2PROMoniInfo->MoniSerialNo[6]  = 0;	// 0
    125          	SaveE2PROMoniInfo->MoniSerialNo[7]  = 0;	// 0
    126          	SaveE2PROMoniInfo->MoniSerialNo[8]  = 0;	// 0
    127          	SaveE2PROMoniInfo->MoniSerialNo[9]  = 0;	// 0
    128          	SaveE2PROMoniInfo->MoniSerialNo[10] = 0;	// *
    129          	SaveE2PROMoniInfo->MoniModel[0]     = 0;	// N
    130          	SaveE2PROMoniInfo->MoniModel[1]     = 0;	// -
    131          	SaveE2PROMoniInfo->MoniModel[2]     = 0;	// H
    132          	SaveE2PROMoniInfo->MoniModel[3]     = 0;	// -
    133          	SaveE2PROMoniInfo->MoniModel[4]     = 0;	// W
    134          	SaveE2PROMoniInfo->MoniModel[5]     = 0;	// *
    135          #endif
    136          
    137          	SerialPutString("\n\rInitialize : 10 %%\n\r");
    138          
    139          	EEPROM_Write(0, 0);	// tmp
    140          	EEPROM_Write(0, 0);	// tmp
    141          	EEPROM_Write(0, 0);	// tmp
    142          
    143          	for(i = 0 ; i < 8 ; i++)
    144          	{
    145          		EEPROM_Write(i+8, tmpBuf1[i]);
    146          		TimeDelay_msec(5);
    147          		EEPROM_Write(i+16, tmpBuf2[i]);
    148          		TimeDelay_msec(5);
    149          		EEPROM_Write(i+24, tmpBuf3[i]);
    150          		TimeDelay_msec(5);
    151          	}
    152          
    153          	SerialPutString("Initialize : 30 %%\n\r");
    154          	
    155          #if 1	// Monitor Change History - temp
    156          	for(i = 0 ; i < 21 ; i++)
    157          	{
    158          		EEPROM_Write(i+50, tmpBuf4[i]);
    159          		TimeDelay_msec(5);
    160          	}
    161          #endif
    162          
    163          	for(i = 0 ; i < 79 ; i++)
    164          	{
    165          		EEPROM_Write(i+100, 0xff);
    166          		TimeDelay_msec(5);
    167          	}
    168          
    169          	SerialPutString("Initialize : 60 %%\n\r");
    170          
    171          	for(i = 0 ; i < 30 ; i++)
    172          	{
    173          		EEPROM_Write(i+200, 0xff);
    174          		TimeDelay_msec(5);
    175          	}
    176          
    177          	for(i = 0 ; i < 29 ; i++)
    178          	{
    179          		EEPROM_Write(i+230, 0xff);
    180          		TimeDelay_msec(5);
    181          	}
    182          
    183          	SerialPutString("Initialize : 95 %%\n\r");
    184          	Init_RTC();
    185          	SerialPutString("Initialize : 100 %%\n\r\n\r");
    186          }
    187          
    188          /**
    189            * @brief  Clock Setting.
    190            * @param  None
    191            * @retval None
    192            */
    193          
    194          RCC_ClocksTypeDef RCC_Clocks;
    195          
    196          void RCC_Configuration(void)
    197          {
    198          	
    199          
    200            	//	SysTick end of count event each 1ms
    201            	RCC_GetClocksFreq(&RCC_Clocks);
    202          
    203          	//	SysTick Timer을 사용하려면, 아래의 설정을 해야되고, 아래의 설정값은 1msec 설정이다.
    204          	#if 0	
    205          	//	Setup SysTick Timer for 1 msec interrupts
    206          	if (SysTick_Config(RCC_Clocks.HCLK_Frequency / 1000))
    207          	{ 
    208          	    /* Capture error */ 
    209              	while (1);
    210            	}
    211          	#endif
    212          	
    213          	RCC_ClockSecuritySystemCmd(ENABLE);
    214          
    215          /**
    216            * @brief  Enables or disables the AHB1 peripheral clock.
    217            * @note   After reset, the peripheral clock (used for registers read/write access)
    218            *         is disabled and the application software has to enable this clock before 
    219            *         using it.   
    220            * @param  RCC_AHBPeriph: specifies the AHB1 peripheral to gates its clock.
    221            *          This parameter can be any combination of the following values:
    222            *            @arg RCC_AHB1Periph_GPIOA:       GPIOA clock
    223            *            @arg RCC_AHB1Periph_GPIOB:       GPIOB clock 
    224            *            @arg RCC_AHB1Periph_GPIOC:       GPIOC clock
    225            *            @arg RCC_AHB1Periph_GPIOD:       GPIOD clock
    226            *            @arg RCC_AHB1Periph_GPIOE:       GPIOE clock
    227            *            @arg RCC_AHB1Periph_GPIOF:       GPIOF clock
    228            *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
    229            *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
    230            *            @arg RCC_AHB1Periph_GPIOI:       GPIOI clock
    231            *            @arg RCC_AHB1Periph_CRC:         CRC clock
    232            *            @arg RCC_AHB1Periph_BKPSRAM:     BKPSRAM interface clock
    233            *            @arg RCC_AHB1Periph_CCMDATARAMEN CCM data RAM interface clock
    234            *            @arg RCC_AHB1Periph_DMA1:        DMA1 clock
    235            *            @arg RCC_AHB1Periph_DMA2:        DMA2 clock
    236            *            @arg RCC_AHB1Periph_ETH_MAC:     Ethernet MAC clock
    237            *            @arg RCC_AHB1Periph_ETH_MAC_Tx:  Ethernet Transmission clock
    238            *            @arg RCC_AHB1Periph_ETH_MAC_Rx:  Ethernet Reception clock
    239            *            @arg RCC_AHB1Periph_ETH_MAC_PTP: Ethernet PTP clock
    240            *            @arg RCC_AHB1Periph_OTG_HS:      USB OTG HS clock
    241            *            @arg RCC_AHB1Periph_OTG_HS_ULPI: USB OTG HS ULPI clock
    242            * @param  NewState: new state of the specified peripheral clock.
    243            *          This parameter can be: ENABLE or DISABLE.
    244            * @retval None
    245            */
    246                  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA1, ENABLE);
    247          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
    248          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
    249          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
    250          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
    251          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOE, ENABLE);
    252          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF, ENABLE);	
    253          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOG, ENABLE);
    254          
    255          /**
    256            * @brief  Enables or disables the AHB2 peripheral clock.
    257            * @note   After reset, the peripheral clock (used for registers read/write access)
    258            *         is disabled and the application software has to enable this clock before 
    259            *         using it. 
    260            * @param  RCC_AHBPeriph: specifies the AHB2 peripheral to gates its clock.
    261            *          This parameter can be any combination of the following values:
    262            *            @arg RCC_AHB2Periph_DCMI:   DCMI clock
    263            *            @arg RCC_AHB2Periph_CRYP:   CRYP clock
    264            *            @arg RCC_AHB2Periph_HASH:   HASH clock
    265            *            @arg RCC_AHB2Periph_RNG:    RNG clock
    266            *            @arg RCC_AHB2Periph_OTG_FS: USB OTG FS clock
    267            * @param  NewState: new state of the specified peripheral clock.
    268            *          This parameter can be: ENABLE or DISABLE.
    269            * @retval None
    270            */
    271          	//RCC_AHB2PeriphClockCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
    272          
    273          /**
    274            * @brief  Enables or disables the AHB3 peripheral clock.
    275            * @note   After reset, the peripheral clock (used for registers read/write access)
    276            *         is disabled and the application software has to enable this clock before 
    277            *         using it. 
    278            * @param  RCC_AHBPeriph: specifies the AHB3 peripheral to gates its clock.
    279            *          This parameter must be: RCC_AHB3Periph_FSMC
    280            * @param  NewState: new state of the specified peripheral clock.
    281            *          This parameter can be: ENABLE or DISABLE.
    282            * @retval None
    283            */
    284          //	++, kutelf, 140801
    285          //	RevD.01.01 
    286          //	DPRAM 삭제 - FSMC 사용 안함. 
    287          #if 1
    288          	RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FSMC, DISABLE);
    289          #else
    290          	RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FSMC, ENABLE);
    291          #endif
    292          //	--, kutelf, 140801
    293          
    294          /**
    295            * @brief  Enables or disables the Low Speed APB (APB1) peripheral clock.
    296            * @note   After reset, the peripheral clock (used for registers read/write access)
    297            *         is disabled and the application software has to enable this clock before 
    298            *         using it. 
    299            * @param  RCC_APB1Periph: specifies the APB1 peripheral to gates its clock.
    300            *          This parameter can be any combination of the following values:
    301            *            @arg RCC_APB1Periph_TIM2:   TIM2 clock
    302            *            @arg RCC_APB1Periph_TIM3:   TIM3 clock
    303            *            @arg RCC_APB1Periph_TIM4:   TIM4 clock
    304            *            @arg RCC_APB1Periph_TIM5:   TIM5 clock
    305            *            @arg RCC_APB1Periph_TIM6:   TIM6 clock
    306            *            @arg RCC_APB1Periph_TIM7:   TIM7 clock
    307            *            @arg RCC_APB1Periph_TIM12:  TIM12 clock
    308            *            @arg RCC_APB1Periph_TIM13:  TIM13 clock
    309            *            @arg RCC_APB1Periph_TIM14:  TIM14 clock
    310            *            @arg RCC_APB1Periph_WWDG:   WWDG clock
    311            *            @arg RCC_APB1Periph_SPI2:   SPI2 clock
    312            *            @arg RCC_APB1Periph_SPI3:   SPI3 clock
    313            *            @arg RCC_APB1Periph_USART2: USART2 clock
    314            *            @arg RCC_APB1Periph_USART3: USART3 clock
    315            *            @arg RCC_APB1Periph_UART4:  UART4 clock
    316            *            @arg RCC_APB1Periph_UART5:  UART5 clock
    317            *            @arg RCC_APB1Periph_I2C1:   I2C1 clock
    318            *            @arg RCC_APB1Periph_I2C2:   I2C2 clock
    319            *            @arg RCC_APB1Periph_I2C3:   I2C3 clock
    320            *            @arg RCC_APB1Periph_CAN1:   CAN1 clock
    321            *            @arg RCC_APB1Periph_CAN2:   CAN2 clock
    322            *            @arg RCC_APB1Periph_PWR:    PWR clock
    323            *            @arg RCC_APB1Periph_DAC:    DAC clock
    324            * @param  NewState: new state of the specified peripheral clock.
    325            *          This parameter can be: ENABLE or DISABLE.
    326            * @retval None
    327            */
    328          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4  , ENABLE);
    329          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM5  , ENABLE);
    330          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2  , ENABLE);
    331          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
    332          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4 , ENABLE);
    333          	//RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2, ENABLE);
    334          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN1  , ENABLE);
    335          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN2  , ENABLE);
    336          
    337          /**
    338            * @brief  Enables or disables the High Speed APB (APB2) peripheral clock.
    339            * @note   After reset, the peripheral clock (used for registers read/write access)
    340            *         is disabled and the application software has to enable this clock before 
    341            *         using it.
    342            * @param  RCC_APB2Periph: specifies the APB2 peripheral to gates its clock.
    343            *          This parameter can be any combination of the following values:
    344            *            @arg RCC_APB2Periph_TIM1:   TIM1 clock
    345            *            @arg RCC_APB2Periph_TIM8:   TIM8 clock
    346            *            @arg RCC_APB2Periph_USART1: USART1 clock
    347            *            @arg RCC_APB2Periph_USART6: USART6 clock
    348            *            @arg RCC_APB2Periph_ADC1:   ADC1 clock
    349            *            @arg RCC_APB2Periph_ADC2:   ADC2 clock
    350            *            @arg RCC_APB2Periph_ADC3:   ADC3 clock
    351            *            @arg RCC_APB2Periph_SDIO:   SDIO clock
    352            *            @arg RCC_APB2Periph_SPI1:   SPI1 clock
    353            *            @arg RCC_APB2Periph_SYSCFG: SYSCFG clock
    354            *            @arg RCC_APB2Periph_TIM9:   TIM9 clock
    355            *            @arg RCC_APB2Periph_TIM10:  TIM10 clock
    356            *            @arg RCC_APB2Periph_TIM11:  TIM11 clock
    357            * @param  NewState: new state of the specified peripheral clock.
    358            *          This parameter can be: ENABLE or DISABLE.
    359            * @retval None
    360            */
    361          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM8  , ENABLE);
    362          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
    363          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
    364          	//RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC2, ENABLE);
    365          	//RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC3, ENABLE);
    366          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1  , ENABLE);
    367          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
    368          }
    369          
    370          /* Private functions ---------------------------------------------------------*/
    371          /**
    372            * @brief  NVIC Setting.
    373            * @param  Configures Vector Table base location.
    374            * @retval None
    375            */
    376          void NVIC_Configuration(void)
    377          {
    378          }
    379          
    380          /* Private functions ---------------------------------------------------------*/
    381          /**
    382            * @brief  GPIO Setting.
    383            * @param  Configures the different GPIO ports.
    384            * @retval None
    385            */
    386          void GPIO_Configuration(void)
    387          {
    388              GPIO_InitTypeDef GPIO_InitStructure;
    389          
    390          
    391          	//  Configure UART1 pins: DEBUG_UART1TX, DEBUG_UART1RX 
    392          	//  UART1은 Debugging으로 사용한다. 이미 설정되어 있음.
    393          #if 0
    394          
    395          	GPIO_InitStructure.GPIO_Pin   = DEBUG_UART1TX | DEBUG_UART1RX;
    396          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;   
    397          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    398          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    399          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    400          	GPIO_Init(DEBUG_UART1_PORT, &GPIO_InitStructure);
    401          
    402          	GPIO_PinAFConfig(DEBUG_UART1_PORT, DEBUG_UART1TX_PinSource, GPIO_AF_USART1);
    403          	GPIO_PinAFConfig(DEBUG_UART1_PORT, DEBUG_UART1RX_PinSource, GPIO_AF_USART1);
    404          
    405          #endif    
    406             
    407          	//  CAN1_TX, CAN1_RX
    408          	GPIO_InitStructure.GPIO_Pin   = CAN1_TX | CAN1_RX;
    409          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;   
    410          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    411          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    412          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    413          	GPIO_Init(CAN1_PORT, &GPIO_InitStructure);
    414          	GPIO_PinAFConfig(CAN1_PORT, CAN1_TX_PinSource, GPIO_AF_CAN1);
    415          	GPIO_PinAFConfig(CAN1_PORT, CAN1_RX_PinSource, GPIO_AF_CAN1);
    416          
    417          	//  CAN2_TX, CAN2_RX
    418          	GPIO_InitStructure.GPIO_Pin   = CAN2_TX | CAN2_RX;
    419          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;   
    420          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    421          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    422          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    423          	GPIO_Init(CAN2_PORT, &GPIO_InitStructure);
    424          	GPIO_PinAFConfig(CAN2_PORT, CAN2_TX_PinSource, GPIO_AF_CAN2);
    425          	GPIO_PinAFConfig(CAN2_PORT, CAN2_RX_PinSource, GPIO_AF_CAN2);
    426          
    427          	//	STM32 UART2 <-> EXYNOS UART1
    428          	GPIO_InitStructure.GPIO_Pin   = UART2TX_EXYNOS1 | UART2RX_EXYNOS1;
    429          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;   
    430          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    431          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    432          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    433          	GPIO_Init(UART2_EXYNOS1_PORT, &GPIO_InitStructure);
    434          	GPIO_PinAFConfig(UART2_EXYNOS1_PORT, UART2TX_EXYNOS1_PinSource, GPIO_AF_USART2);
    435          	GPIO_PinAFConfig(UART2_EXYNOS1_PORT, UART2RX_EXYNOS1_PinSource, GPIO_AF_USART2);
    436          #if 0
    437          //	++, kutelf, 140801
    438          //	RevD.01.01 
    439          //	TW8832 -> TW8816 변경 
    440          //  GPIO로 I2C2 사용
    441          //  Alternate Function 사용안함
    442          #ifdef BoardVersion_RevD
    443          	GPIO_InitStructure.GPIO_Pin   = TW8816_I2C2_SCL | TW8816_I2C2_SDA;
    444          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    445          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    446          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    447          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    448          	GPIO_Init(TW8816_I2C2_PORT, &GPIO_InitStructure);
    449          #else
    450          //	RevD 이하 버젼에서 사용 
    451          	GPIO_InitStructure.GPIO_Pin   = TW8832_I2C2_SCL | TW8832_I2C2_SDA;
    452          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    453          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    454          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    455          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    456          	GPIO_Init(TW8832_I2C2_PORT, &GPIO_InitStructure);
    457          //	GPIO_PinAFConfig(TW8832_I2C2_PORT, TW8832_I2C2_SCL_PinSource, GPIO_AF_I2C2);
    458          //	GPIO_PinAFConfig(TW8832_I2C2_PORT, TW8832_I2C2_SDA_PinSource, GPIO_AF_I2C2);
    459          #endif
    460          //	--, kutelf, 140801
    461          #endif
    462          	//	STM32 UART4 <-> EXYNOS UART3
    463          	GPIO_InitStructure.GPIO_Pin   = UART4TX_EXYNOS3 | UART4RX_EXYNOS3;
    464          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;   
    465          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    466          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    467          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    468          	GPIO_Init(UART4_EXYNOS3_PORT, &GPIO_InitStructure);
    469          	GPIO_PinAFConfig(UART4_EXYNOS3_PORT, UART4TX_EXYNOS3_PinSource, GPIO_AF_UART4);
    470          	GPIO_PinAFConfig(UART4_EXYNOS3_PORT, UART4RX_EXYNOS3_PinSource, GPIO_AF_UART4);
    471          
    472          	//  EXYNOS PWR_CTRL -> GPIO Output
    473          	GPIO_InitStructure.GPIO_Pin   = EXYNOS_PWR_CTRL;
    474          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    475          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    476          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    477          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    478          	GPIO_Init(EXYNOS_PWR_CTRL_PORT, &GPIO_InitStructure);
    479          
    480          	//  EXYNOS PMIC_CTRL -> GPIO Output
    481          	GPIO_InitStructure.GPIO_Pin   = EXYNOS_PMIC_CTRL;
    482          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    483          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    484          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    485          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    486          	GPIO_Init(EXYNOS_PMIC_CTRL_PORT, &GPIO_InitStructure);
    487          
    488          	//	Serial Flash -> STM32 Update (SPI1)
    489          	GPIO_InitStructure.GPIO_Pin   = SFLASH_SPI1_CS | SFLASH_SPI1_SCK | SFLASH_SPI1_MOSI;
    490          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    491          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    492          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    493          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    494          	GPIO_Init(SFLASH_SPI1_PORT, &GPIO_InitStructure);
    495          
    496          	GPIO_InitStructure.GPIO_Pin   = SFLASH_SPI1_MISO;
    497          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;   
    498          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    499          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    500          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    501          	GPIO_Init(SFLASH_SPI1_PORT, &GPIO_InitStructure);
    502          
    503          	GPIO_InitStructure.GPIO_Pin   = SFLASH_HOLD | SFLASH_WP;
    504          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    505          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    506          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    507          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    508          	GPIO_Init(SFLASH_PORT, &GPIO_InitStructure);
    509          
    510          	//	LAMP GPIO (Serial Data -> Parallel Data
    511          	GPIO_InitStructure.GPIO_Pin   = LAMP_CLR | LAMP_SLCLK | LAMP_SCLK | LAMP_SDATA;
    512          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    513          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    514          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    515          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    516          	GPIO_Init(LAMP_PORT, &GPIO_InitStructure);
    517          
    518          	//	Hardware Version -> ADC
    519          	GPIO_InitStructure.GPIO_Pin   = HW_VERSION;
    520          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AN;   
    521          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    522          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
    523          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    524          	GPIO_Init(HW_VERSION_PORT, &GPIO_InitStructure);
    525          
    526          	//	KeySwitch Matrix -> GPIO Output
    527          	GPIO_InitStructure.GPIO_Pin   = KeySCAN0 | KeySCAN1 | KeySCAN2;
    528          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    529          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    530          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    531          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    532          	GPIO_Init(KeySWXX_PORT, &GPIO_InitStructure);
    533          
    534          	//	KeySwitch Matrix -> GPIO Input
    535          	GPIO_InitStructure.GPIO_Pin   = KeyInput0 | KeyInput1 | KeyInput2 | KeyInput3 | KeyInput4 | KeyInput5;
    536          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;   
    537          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    538          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    539          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    540          	GPIO_Init(KeySWXX_PORT, &GPIO_InitStructure);
    541          
    542          	//  POWER_IGMON -> GPIO Input
    543          	GPIO_InitStructure.GPIO_Pin   = PWR_IGMON;
    544          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;   
    545          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    546          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    547          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    548          	GPIO_Init(PWR_IGMON_PORT, &GPIO_InitStructure);
    549          
    550          	//  POWER_CTRL -> GPIO Output
    551          	GPIO_InitStructure.GPIO_Pin   = PWR_CTRL;
    552          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    553          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    554          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    555          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    556          	GPIO_Init(PWR_CTRL_PORT, &GPIO_InitStructure);
    557          
    558          	//  LCDPWR_CTRL -> GPIO Output
    559          	GPIO_InitStructure.GPIO_Pin   = LCDPWR_CTRL;
    560          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    561          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    562          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    563          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    564          	GPIO_Init(LCDPWR_PORT, &GPIO_InitStructure);
    565          //	++, kutelf, 140801
    566          //	RevD.01.01 
    567          //	FW_UPDATE 삭제 
    568          //	RevD 이하 버젼에서 사용 
    569          #ifndef BoardVersion_RevD
    570          	//  FW_UPDATE -> GPIO Input
    571          	GPIO_InitStructure.GPIO_Pin   = FW_UPDATE;
    572          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;   
    573          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    574          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    575          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    576          	GPIO_Init(FW_UPDATE_PORT, &GPIO_InitStructure);
    577          #endif
    578          //	--, kutelf, 140801
    579          	//	LCDBL_PWM -> PWM
    580          	GPIO_InitStructure.GPIO_Pin   = LCDBL_PWM;
    581          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;   
    582          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    583          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    584          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
    585          	GPIO_Init(LCDBL_PORT, &GPIO_InitStructure);
    586          	GPIO_PinAFConfig(LCDBL_PORT, LCDBL_PWM_PinSource, GPIO_AF_TIM8);
    587          
    588          	//  LCDBL_CTRL -> GPIO Output
    589          	GPIO_InitStructure.GPIO_Pin   = LCDBL_CTRL;
    590          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    591          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    592          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    593          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    594          	GPIO_Init(LCDBL_PORT, &GPIO_InitStructure);
    595          	
    596          	//  LCD_STM32 -> GPIO Output
    597          	GPIO_InitStructure.GPIO_Pin   = LCD_STM32;
    598          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    599          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    600          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    601          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    602          	GPIO_Init(LCD_STM32_PORT, &GPIO_InitStructure);
    603          
    604          	//  LCD_EXYNOS -> GPIO Output
    605          	GPIO_InitStructure.GPIO_Pin   = LCD_EXYNOS;
    606          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    607          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    608          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    609          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    610          	GPIO_Init(LCD_EXYNOS_PORT, &GPIO_InitStructure);
    611          
    612          	//  BUZZER_CTRL -> GPIO Output
    613          	GPIO_InitStructure.GPIO_Pin   = BUZZER_CTRL;
    614          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    615          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    616          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    617          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    618          	GPIO_Init(BUZZER_PORT, &GPIO_InitStructure);
    619          
    620          	//  LED_CTRL -> GPIO Output
    621          	GPIO_InitStructure.GPIO_Pin   = LED_CTRL;
    622          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    623          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    624          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    625          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    626          	GPIO_Init(LED_PORT, &GPIO_InitStructure);
    627          
    628          	//  FM31X4(EEPROM) -> GPIO Output
    629          	//  GPIO로 I2C1 사용
    630          	//  Alternate Function 사용안함
    631          	GPIO_InitStructure.GPIO_Pin   = FM31X4_I2C1_SCL | FM31X4_I2C1_SDA;
    632          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    633          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    634          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    635          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    636          	GPIO_Init(FM31X4_I2C1_PORT, &GPIO_InitStructure);
    637          
    638          //	++, kutelf, 140801
    639          //	RevD.01.01 
    640          //	TW2835 삭제 
    641          //	RevD 이하 버젼에서 사용 
    642          #ifndef BoardVersion_RevD
    643          	//  TW2835 -> GPIO Output
    644          	GPIO_InitStructure.GPIO_Pin   = TW2835_IRQ| TW2835_HALE | TW2835_HSPB;
    645          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    646          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    647          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    648          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    649          	GPIO_Init(TW2835_CTRLPORT, &GPIO_InitStructure);
    650          
    651          	GPIO_InitStructure.GPIO_Pin   = TW2835_D0 | TW2835_D1 | TW2835_D2 | TW2835_D3 | TW2835_D4 | TW2835_D5 | TW2835_D6 | TW2835_D7;
    652          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    653          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    654          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    655          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    656          	GPIO_Init(TW2835_DATAPORT, &GPIO_InitStructure);	
    657          
    658          	GPIO_InitStructure.GPIO_Pin   = TW2835_CSB0 | TW2835_CSB1 | TW2835_nWE | TW2835_nOE;
    659          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    660          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    661          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    662          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    663          	GPIO_Init(TW2835_DATAPORT, &GPIO_InitStructure);
    664          #endif
    665          //	--, kutelf, 140801
    666          
    667          //	++, kutelf, 140801
    668          //	RevD.01.01 
    669          //	DPRAM 삭제 - FSMS 사용 안함. 
    670          #if 0
    671          	//  DPRAM INT -> GPIO Output
    672          	GPIO_InitStructure.GPIO_Pin   = DPRAM_INT;
    673          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;   
    674          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    675          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    676          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    677          	GPIO_Init(DPRAM_PORT, &GPIO_InitStructure);
    678          #endif
    679          //	--, kutelf, 140801
    680          
    681          	//  CAMERA nRESET -> GPIO Output
    682          	GPIO_InitStructure.GPIO_Pin   = CAMERA_nRESET;
    683          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    684          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    685          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    686          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    687          	GPIO_Init(CAMERA_nRESET_PORT, &GPIO_InitStructure);
    688          
    689          //	++, kutelf, 140801
    690          //	RevD.01.01 
    691          //	EXYNOS PMIC nRESET 추가 
    692          #if 1
    693          	GPIO_InitStructure.GPIO_Pin   = EXYNOS_PMIC_nRESET;
    694          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    695          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    696          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    697          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    698          	GPIO_Init(EXYNOS_PMIC_nRESET_PORT, &GPIO_InitStructure);
    699          #endif
    700          //	--, kutelf, 140801
    701          
    702          
    703          //	++, kutelf, 140801
    704          //	RevD.01.01 
    705          //	DPRAM 삭제 - FSMC 사용 안함. 
    706          #if 0
    707          	// 	FSMC Data Line
    708          	//  D15 ~ D0 : D15  D14  D13 D12  D11  D10  D9   D8   D7   D6  D5  D4  D3  D2  D1   D0   
    709          	//             PD10 PD9  PD8 PE15 PE14 PE13 PE12 PE11 PE10 PE9 PE8 PE7 PD1 PD0 PD15 PD14
    710          
    711          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10| GPIO_Pin_9  | GPIO_Pin_8 | GPIO_Pin_1 |
    712          	GPIO_Pin_0 | GPIO_Pin_15 | GPIO_Pin_14;
    713          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
    714          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
    715          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    716          	GPIO_Init(GPIOD, &GPIO_InitStructure);
    717          
    718          	GPIO_PinAFConfig(GPIOD, GPIO_PinSource10, GPIO_AF_FSMC);
    719          	GPIO_PinAFConfig(GPIOD, GPIO_PinSource9 , GPIO_AF_FSMC);
    720          	GPIO_PinAFConfig(GPIOD, GPIO_PinSource8 , GPIO_AF_FSMC);
    721          	GPIO_PinAFConfig(GPIOD, GPIO_PinSource1 , GPIO_AF_FSMC);
    722          	GPIO_PinAFConfig(GPIOD, GPIO_PinSource0 , GPIO_AF_FSMC);
    723          	GPIO_PinAFConfig(GPIOD, GPIO_PinSource15, GPIO_AF_FSMC);
    724          	GPIO_PinAFConfig(GPIOD, GPIO_PinSource14, GPIO_AF_FSMC);	
    725            
    726          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_15 | GPIO_Pin_14 | GPIO_Pin_13 | GPIO_Pin_12 |
    727          								GPIO_Pin_11 | GPIO_Pin_10 | GPIO_Pin_9  |
    728          								GPIO_Pin_8  | GPIO_Pin_7;
    729          	GPIO_Init(GPIOE, &GPIO_InitStructure);
    730          
    731          	GPIO_PinAFConfig(GPIOE, GPIO_PinSource15, GPIO_AF_FSMC);
    732          	GPIO_PinAFConfig(GPIOE, GPIO_PinSource14, GPIO_AF_FSMC);
    733          	GPIO_PinAFConfig(GPIOE, GPIO_PinSource13, GPIO_AF_FSMC);
    734          	GPIO_PinAFConfig(GPIOE, GPIO_PinSource12, GPIO_AF_FSMC);
    735          	GPIO_PinAFConfig(GPIOE, GPIO_PinSource11, GPIO_AF_FSMC);
    736          	GPIO_PinAFConfig(GPIOE, GPIO_PinSource10, GPIO_AF_FSMC);
    737          	GPIO_PinAFConfig(GPIOE, GPIO_PinSource9 , GPIO_AF_FSMC);	
    738          	GPIO_PinAFConfig(GPIOE, GPIO_PinSource8 , GPIO_AF_FSMC);	
    739          	GPIO_PinAFConfig(GPIOE, GPIO_PinSource7 , GPIO_AF_FSMC);	
    740          
    741          	//  nCLK, nOE, nWE, nWait
    742          	GPIO_InitStructure.GPIO_Pin = FSMC_nOE | FSMC_nWE | FSMC_nWAIT | FSMC_nCLK;
    743          	GPIO_Init(FSMC_PORT, &GPIO_InitStructure);
    744          
    745          	GPIO_PinAFConfig(FSMC_PORT, FSMC_nOE_PinSource  , GPIO_AF_FSMC);
    746          	GPIO_PinAFConfig(FSMC_PORT, FSMC_nWE_PinSource  , GPIO_AF_FSMC);
    747          	GPIO_PinAFConfig(FSMC_PORT, FSMC_nWAIT_PinSource, GPIO_AF_FSMC);
    748          	GPIO_PinAFConfig(FSMC_PORT, FSMC_nCLK_PinSource , GPIO_AF_FSMC);
    749          
    750          	//  nBL0, nBL1
    751          	GPIO_InitStructure.GPIO_Pin = FSMC_nBL0 | FSMC_nBL1;
    752          	GPIO_Init(FSMC_nBL_PORT, &GPIO_InitStructure);
    753          
    754          	GPIO_PinAFConfig(FSMC_nBL_PORT, FSMC_nBL0_PinSource  , GPIO_AF_FSMC);
    755          	GPIO_PinAFConfig(FSMC_nBL_PORT, FSMC_nBL1_PinSource  , GPIO_AF_FSMC);
    756          
    757          	//	nADV
    758          	GPIO_InitStructure.GPIO_Pin = FSMC_nADV;
    759          	GPIO_PinAFConfig(FSMC_ADVPORT, FSMC_nADV_PinSource  , GPIO_AF_FSMC);
    760          	GPIO_Init(FSMC_ADVPORT, &GPIO_InitStructure);
    761          
    762          	// NE1 configuration
    763          	GPIO_InitStructure.GPIO_Pin = FSMC_nNE1;
    764          	GPIO_Init(FSMC_nNE1_PORT, &GPIO_InitStructure);
    765          
    766          	GPIO_PinAFConfig(FSMC_nNE1_PORT, FSMC_nNE1_PinSource  , GPIO_AF_FSMC);
    767          #endif
    768          //	--, kutelf, 140801
    769          
    770          	//++, 160512 bwk
    771          	// RevH.01.01부터 
    772          	//	Configure CPU_DIE
    773          	GPIO_InitStructure.GPIO_Pin   = CPU_DIE;
    774          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    775          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    776          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    777          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    778          	GPIO_Init(CPU_DIE_PORT, &GPIO_InitStructure);	 
    779          
    780          	// WATCH DOG ENABLE
    781          	GPIO_InitStructure.GPIO_Pin   = WD_EN;
    782          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    783          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    784          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    785          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    786          	GPIO_Init(WD_EN_PORT, &GPIO_InitStructure);	
    787          	// --, 160512 bwk
    788          
    789          
    790              //  사용하지 않는 GPIO Pin은 Output -> Low 상태로 만들어 놓는다.
    791              //GPIO_Configuration_NotUsed();
    792          }
    793          
    794          /**
    795            * @brief  GPIO Setting.
    796            * @param  Configures the different GPIO ports. (사용하지 않는 GPIO는 Output Low 상태로 만든다.)
    797            * @retval None
    798            */
    799          void GPIO_Configuration_NotUsed(void)
    800          {
    801              GPIO_InitTypeDef GPIO_InitStructure;
    802          
    803          //	++, kutelf, 140801
    804          //	RevD.01.01 
    805          //	사용하지 않는 핀 : Output Low 상태로 설정. 
    806          #ifdef BoardVersion_RevD
    807          	//  PB7
    808              GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_7;
    809              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    810            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    811            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    812              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    813              GPIO_Init(GPIOB, &GPIO_InitStructure);
    814          
    815          	//  PC0, PC1, PC2, PC5, PC8, PC13
    816              GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_5 | GPIO_Pin_8 | GPIO_Pin_13;
    817              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    818            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    819            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    820              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    821              GPIO_Init(GPIOC, &GPIO_InitStructure);
    822          
    823          	//  PD0, PD1, PD3, PD4, PD5, PD6, PD7, PD8, PD9, PD10, PD11, PD12, PD13, PD14, PD15
    824              GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7 |
    825              								GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
    826              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    827            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    828            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    829              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    830              GPIO_Init(GPIOD, &GPIO_InitStructure);
    831          
    832          	//  PE0, PE1, PE2, PE3, PE4, PE5, PE6, PE7, PE8, PE9, PE10, PE11, PE12, PE13, PE14, PE15
    833              GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 |
    834              								GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13 |
    835              								GPIO_Pin_14 | GPIO_Pin_15;
    836              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    837            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    838            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    839              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    840              GPIO_Init(GPIOE, &GPIO_InitStructure);
    841          
    842          
    843          	//  PF3, PF4, PF5, PF6, PF7, PF8, PF9
    844              GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9;
    845              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    846            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    847            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    848              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    849              GPIO_Init(GPIOF, &GPIO_InitStructure);
    850          
    851          	// ++, 160512 bwk
    852          #if 0
    853          	//  PG0, PG1, PG2, PG3, PG4, PG5, PG6, PG7, PG8, PG9, PG10, GP12, PG13, PG14
    854          	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7 |
    855          	GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14;
    856          #else
    857          	//  PG0, PG1, PG2, PG3, PG4, PG5, PG8, PG9, PG10, GP12, PG13, PG14
    858          	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | 
    859          	GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14;
    860          #endif
    861          	// --, 160512 bwk    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    862            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    863            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    864          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    865          	GPIO_Init(GPIOG, &GPIO_InitStructure);
    866          	
    867          
    868              GPIO_ResetBits(GPIOB, GPIO_Pin_7); 
    869          
    870              GPIO_ResetBits(GPIOC, GPIO_Pin_0); 
    871              GPIO_ResetBits(GPIOC, GPIO_Pin_1); 
    872              GPIO_ResetBits(GPIOC, GPIO_Pin_2); 
    873              GPIO_ResetBits(GPIOC, GPIO_Pin_5); 
    874              GPIO_ResetBits(GPIOC, GPIO_Pin_8); 
    875              GPIO_ResetBits(GPIOC, GPIO_Pin_13); 	
    876          
    877              GPIO_ResetBits(GPIOD, GPIO_Pin_0); 		
    878              GPIO_ResetBits(GPIOD, GPIO_Pin_1); 		
    879              GPIO_ResetBits(GPIOD, GPIO_Pin_3); 		
    880              GPIO_ResetBits(GPIOD, GPIO_Pin_4); 		
    881              GPIO_ResetBits(GPIOD, GPIO_Pin_5); 		
    882              GPIO_ResetBits(GPIOD, GPIO_Pin_6); 		
    883              GPIO_ResetBits(GPIOD, GPIO_Pin_7); 		
    884              GPIO_ResetBits(GPIOD, GPIO_Pin_8); 		
    885              GPIO_ResetBits(GPIOD, GPIO_Pin_9); 		
    886              GPIO_ResetBits(GPIOD, GPIO_Pin_10); 		
    887              GPIO_ResetBits(GPIOD, GPIO_Pin_11); 		
    888              GPIO_ResetBits(GPIOD, GPIO_Pin_12); 		
    889              GPIO_ResetBits(GPIOD, GPIO_Pin_13); 		
    890              GPIO_ResetBits(GPIOD, GPIO_Pin_14); 		
    891              GPIO_ResetBits(GPIOD, GPIO_Pin_15); 		
    892          	
    893              GPIO_ResetBits(GPIOE, GPIO_Pin_0); 		
    894              GPIO_ResetBits(GPIOE, GPIO_Pin_1); 		
    895              GPIO_ResetBits(GPIOE, GPIO_Pin_2); 		
    896              GPIO_ResetBits(GPIOE, GPIO_Pin_3); 		
    897              GPIO_ResetBits(GPIOE, GPIO_Pin_4); 		
    898              GPIO_ResetBits(GPIOE, GPIO_Pin_5); 		
    899              GPIO_ResetBits(GPIOE, GPIO_Pin_6); 		
    900              GPIO_ResetBits(GPIOE, GPIO_Pin_7); 		
    901              GPIO_ResetBits(GPIOE, GPIO_Pin_8); 		
    902              GPIO_ResetBits(GPIOE, GPIO_Pin_9); 		
    903              GPIO_ResetBits(GPIOE, GPIO_Pin_10); 		
    904              GPIO_ResetBits(GPIOE, GPIO_Pin_11); 		
    905              GPIO_ResetBits(GPIOE, GPIO_Pin_12); 		
    906              GPIO_ResetBits(GPIOE, GPIO_Pin_13); 		
    907              GPIO_ResetBits(GPIOE, GPIO_Pin_14); 		
    908              GPIO_ResetBits(GPIOE, GPIO_Pin_15); 		
    909          
    910              GPIO_ResetBits(GPIOF, GPIO_Pin_3); 		
    911              GPIO_ResetBits(GPIOF, GPIO_Pin_4); 		
    912              GPIO_ResetBits(GPIOF, GPIO_Pin_5); 		
    913              GPIO_ResetBits(GPIOF, GPIO_Pin_6); 		
    914              GPIO_ResetBits(GPIOF, GPIO_Pin_7); 		
    915              GPIO_ResetBits(GPIOF, GPIO_Pin_8); 		
    916              GPIO_ResetBits(GPIOF, GPIO_Pin_9); 		
    917          
    918              GPIO_ResetBits(GPIOG, GPIO_Pin_0); 		
    919              GPIO_ResetBits(GPIOG, GPIO_Pin_1); 			
    920              GPIO_ResetBits(GPIOG, GPIO_Pin_2); 		
    921              GPIO_ResetBits(GPIOG, GPIO_Pin_3); 			
    922              GPIO_ResetBits(GPIOG, GPIO_Pin_4); 		
    923              GPIO_ResetBits(GPIOG, GPIO_Pin_5); 			
    924              // ++, 160512 bwk
    925              #if 0
    926              GPIO_ResetBits(GPIOG, GPIO_Pin_6); 		
    927              GPIO_ResetBits(GPIOG, GPIO_Pin_7); 			
    928              #endif
    929              // --, 160512 bwk
    930              GPIO_ResetBits(GPIOG, GPIO_Pin_8); 		
    931              GPIO_ResetBits(GPIOG, GPIO_Pin_9); 			
    932              GPIO_ResetBits(GPIOG, GPIO_Pin_10); 			
    933              GPIO_ResetBits(GPIOG, GPIO_Pin_12); 			
    934              GPIO_ResetBits(GPIOG, GPIO_Pin_13); 			
    935              GPIO_ResetBits(GPIOG, GPIO_Pin_14); 				
    936          	
    937          #else
    938          //	RevD 이하 버젼에서 사용 	
    939          	//  PC2
    940              GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_2;
    941              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    942            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    943            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    944              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    945              GPIO_Init(GPIOC, &GPIO_InitStructure);
    946          
    947          	//  PC8
    948              GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_8;
    949              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    950            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    951            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    952              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    953              GPIO_Init(GPIOC, &GPIO_InitStructure);
    954          
    955          	//  PB7
    956              GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_7;
    957              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    958            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    959            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    960              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    961              GPIO_Init(GPIOB, &GPIO_InitStructure);
    962          
    963          	//  PC15
    964              GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_15;
    965              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
    966            	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    967            	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    968              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    969              GPIO_Init(GPIOC, &GPIO_InitStructure);
    970          	
    971              GPIO_ResetBits(GPIOC, GPIO_Pin_2);
    972              GPIO_ResetBits(GPIOC, GPIO_Pin_8);
    973              GPIO_ResetBits(GPIOC, GPIO_Pin_15);
    974              GPIO_ResetBits(GPIOB, GPIO_Pin_7);	
    975          #endif
    976          //	--, kutelf, 140801
    977          }
    978          
    979          /**
    980            * @brief  Hardware, Software System Configuration.
    981            * @param  None
    982            * @retval None
    983            */
    984          void System_Configuration(void)
    985          {
    986          	RCC_Configuration();		    // 	Configure the system clocks
    987          	NVIC_Configuration();		    //	NVIC Configuration
    988          	GPIO_Configuration();		    // 	Configure the GPIO port	
    989          }
    990          
    991          void System_Initialize(void)
    992          {
    993          	//  PWR_CTRL -> BootLoader에서는 Sub Power Enable을 Off 
    994          	GPIO_ResetBits(PWR_CTRL_PORT, PWR_CTRL);   	//	24V Power Enable 
    995          	                                //  Set   : Power Enable On
    996          	                                //  Reset : Power Enable Off    	
    997          
    998          	//  LCDPWR_CTRL -> BootLoader에서는 VLCD12 Power Enable을 Off 
    999          	GPIO_ResetBits(LCDPWR_PORT, LCDPWR_CTRL);  	//	LCD Power Enable 
   1000          	                                //  Set   : LCD Power Enable 
   1001          	                                //  Reset : LCD Power Disable	
   1002          
   1003          	//  BootLoader Bootting시에, LCDBL는 Off 상태로 만든다.
   1004          	GPIO_ResetBits(LCDBL_PORT, LCDBL_CTRL);	    //	LCD BackLight Power On/Off (LCDBL_CTRL)
   1005          	                               	//  Set   : BackLight Power On
   1006          	                               	//  Reset : BackLight Power Off			
   1007          	                               	
   1008          	GPIO_ResetBits(BUZZER_PORT, BUZZER_CTRL);	//	BUZZER Off
   1009          	                                //  Set   : BUZZER On
   1010          	                                //  Reset : BUZZER Off
   1011          
   1012          	GPIO_ResetBits(LED_PORT, LED_CTRL);			//	LED Enable Off
   1013          	                                //  Set   : LED Enable  -> On
   1014          	                                //  Reset : LED Disable -> Off
   1015          
   1016          
   1017          	// ++, 150811 sys 
   1018          	#if 0								
   1019          	                             			
   1020          	GPIO_ResetBits(EXYNOS_PMIC_CTRL_PORT, EXYNOS_PMIC_CTRL);	//	Exynos-4412 PMIC On/Off
   1021          	                                				//  PMIC On  : Low -> High
   1022          	                                				//       Off : Low -> High
   1023          	//	++, kutelf, 140801
   1024          	//	RevD.01.01 
   1025          	//	EXYNOS PMIC nRESET => Reset 상태로 초기화 
   1026          	GPIO_SetBits(EXYNOS_PMIC_nRESET_PORT, EXYNOS_PMIC_nRESET);	//	Exynos-4412 PMIC nRESET
   1027          	                                				//  PMIC On  : High
   1028          	                                				//       Off : Low
   1029          	//	--, kutelf, 140801
   1030          
   1031          	#endif
   1032          	// --, 150811 sys
   1033          	
   1034          	GPIO_ResetBits(LCD_EXYNOS_PORT, LCD_EXYNOS);	//	Exynos-4412 LCD Display
   1035          	                                //  Set   : HI-Z
   1036          	                                //  Reset : Display
   1037          	                                    				
   1038          	GPIO_SetBits(LCD_STM32_PORT, LCD_STM32);	//	STM32 LCD Display
   1039          	                                //  Set   : HI-Z
   1040          	                                //  Reset : Display
   1041          
   1042          	GPIO_ResetBits(CAMERA_nRESET_PORT, CAMERA_nRESET);	//	CAMERA nRESET
   1043          	                                        //  Set   : On
   1044          	                                        //  Reset : Off		
   1045          }
   1046          // ++, sys3215, 141211
   1047          void Camera_IO_Init(void)
   1048          {
   1049                  
   1050            	GPIO_InitTypeDef GPIO_InitStructure;
   1051                  
   1052            	GPIO_InitStructure.GPIO_Pin   = TW8816_I2C2_SCL | TW8816_I2C2_SDA;
   1053          	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;   
   1054          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   1055          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
   1056          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   1057          	GPIO_Init(TW8816_I2C2_PORT, &GPIO_InitStructure);
   1058                  GPIO_Configuration_NotUsed();
   1059          }
   1060          /*********(C) COPYRIGHT 2013 TaeHa Mechatronics Co., Ltd. *****END OF FILE****/
   1061          
   1062          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   Camera_IO_Init
        16   -> GPIO_Configuration_NotUsed
        16   -> GPIO_Init
      32   GPIO_Configuration
        32   -> GPIO_Init
        32   -> GPIO_PinAFConfig
      24   GPIO_Configuration_NotUsed
        24   -> GPIO_Init
        24   -> GPIO_ResetBits
      72   InitE2PROM
        72   -> EEPROM_Write
        72   -> Init_RTC
        72   -> Serial_PutString
        72   -> TimeDelay_msec
      16   Init_RTC
        16   -> WRITE_RTC
       0   NVIC_Configuration
       8   RCC_Configuration
         8   -> RCC_AHB1PeriphClockCmd
         8   -> RCC_AHB3PeriphClockCmd
         8   -> RCC_APB1PeriphClockCmd
         0   -> RCC_APB2PeriphClockCmd
         8   -> RCC_APB2PeriphClockCmd
         8   -> RCC_ClockSecuritySystemCmd
         8   -> RCC_GetClocksFreq
       8   System_Configuration
         0   -> GPIO_Configuration
         8   -> RCC_Configuration
      16   System_Initialize
         0   -> GPIO_ResetBits
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      24  ?<Constant "Initialize : 100 %%\n\r\n\r">
      24  ?<Constant "Initialize : 30 %%\n\r">
      24  ?<Constant "Initialize : 60 %%\n\r">
      24  ?<Constant "Initialize : 95 %%\n\r">
      24  ?<Constant "\n\rInitialize : 10 %%\n\r">
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
      50  Camera_IO_Init
    1248  GPIO_Configuration
     196  GPIO_Configuration_NotUsed
     500  InitE2PROM
      50  Init_RTC
       2  NVIC_Configuration
      16  RCC_Clocks
     206  RCC_Configuration
      16  SaveE2PROM1
          SaveE2PROM2
          SaveE2PROM3
          SaveE2PROMoniInfo
      12  System_Configuration
      84  System_Initialize
       8  WL9FM_RTC

 
    40 bytes in section .bss
 2 504 bytes in section .text
 
 2 504 bytes of CODE memory
    40 bytes of DATA memory

Errors: none
Warnings: none
